"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@levischuck";
exports.ids = ["vendor-chunks/@levischuck"];
exports.modules = {

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js":
/*!*************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* binding */ CBORTag),\n/* harmony export */   decodeCBOR: () => (/* binding */ decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* binding */ decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* binding */ encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor_internal.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\");\n\n/**\n * A value which is wrapped with a CBOR Tag.\n * Several tags are registered with defined meanings like 0 for a date string.\n * These meanings are **not interpreted** when decoded or encoded.\n *\n * This class is an immutable record.\n * If the tag number or value needs to change, then construct a new tag\n */\nclass CBORTag {\n    /**\n     * Wrap a value with a tag number.\n     * When encoded, this tag will be attached to the value.\n     *\n     * @param tag Tag number\n     * @param value Wrapped value\n     */\n    constructor(tag, value) {\n        Object.defineProperty(this, \"tagId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tagValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tagId = tag;\n        this.tagValue = value;\n    }\n    /**\n     * Read the tag number\n     */\n    get tag() {\n        return this.tagId;\n    }\n    /**\n     * Read the value\n     */\n    get value() {\n        return this.tagValue;\n    }\n}\nfunction decodeUnsignedInteger(data, argument, index) {\n    return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n}\nfunction decodeNegativeInteger(data, argument, index) {\n    const [value, length] = decodeUnsignedInteger(data, argument, index);\n    return [-value - 1, length];\n}\nfunction decodeByteString(data, argument, index) {\n    const [lengthValue, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const dataStartIndex = index + lengthConsumed;\n    return [\n        new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),\n        lengthConsumed + lengthValue,\n    ];\n}\nconst TEXT_DECODER = new TextDecoder();\nfunction decodeString(data, argument, index) {\n    const [value, length] = decodeByteString(data, argument, index);\n    return [TEXT_DECODER.decode(value), length];\n}\nfunction decodeArray(data, argument, index) {\n    if (argument === 0) {\n        return [[], 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const value = [];\n    for (let i = 0; i < length; i++) {\n        const remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(\"array is not supported or well formed\");\n        }\n        const [decodedValue, consumed] = decodeNext(data, index + consumedLength);\n        value.push(decodedValue);\n        consumedLength += consumed;\n    }\n    return [value, consumedLength];\n}\nconst MAP_ERROR = \"Map is not supported or well formed\";\nfunction decodeMap(data, argument, index) {\n    if (argument === 0) {\n        return [new Map(), 1];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const result = new Map();\n    for (let i = 0; i < length; i++) {\n        let remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load key\n        const [key, keyConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += keyConsumed;\n        remainingDataLength -= keyConsumed;\n        // Check that there's enough to have a value\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Technically CBOR maps can have any type as the key, and so can JS Maps\n        // However, JS Maps can only reference such keys as references which would\n        // require key iteration and pattern matching.\n        // For simplicity, since such keys are not in use with WebAuthn, this\n        // capability is not implemented and the types are restricted to strings\n        // and numbers.\n        if (typeof key !== \"string\" && typeof key !== \"number\") {\n            throw new Error(MAP_ERROR);\n        }\n        // CBOR Maps are not well formed if there are duplicate keys\n        if (result.has(key)) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load value\n        const [value, valueConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += valueConsumed;\n        result.set(key, value);\n    }\n    return [result, consumedLength];\n}\nfunction decodeFloat16(data, index) {\n    if (index + 3 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 16\");\n    }\n    // Skip the first byte\n    const result = data.getUint16(index + 1, false);\n    // A minimal selection of supported values\n    if (result == 0x7c00) {\n        return [Infinity, 3];\n    }\n    else if (result == 0x7e00) {\n        return [NaN, 3];\n    }\n    else if (result == 0xfc00) {\n        return [-Infinity, 3];\n    }\n    throw new Error(\"Float16 data is unsupported\");\n}\nfunction decodeFloat32(data, index) {\n    if (index + 5 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 32\");\n    }\n    // Skip the first byte\n    const result = data.getFloat32(index + 1, false);\n    // First byte + 4 byte float\n    return [result, 5];\n}\nfunction decodeFloat64(data, index) {\n    if (index + 9 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 64\");\n    }\n    // Skip the first byte\n    const result = data.getFloat64(index + 1, false);\n    // First byte + 8 byte float\n    return [result, 9];\n}\nfunction decodeTag(data, argument, index) {\n    const [tag, tagBytes] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const [value, valueBytes] = decodeNext(data, index + tagBytes);\n    return [new CBORTag(tag, value), tagBytes + valueBytes];\n}\nfunction decodeNext(data, index) {\n    if (index >= data.byteLength) {\n        throw new Error(\"CBOR stream ended before tag value\");\n    }\n    const byte = data.getUint8(index);\n    const majorType = byte >> 5;\n    const argument = byte & 0x1f;\n    switch (majorType) {\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER: {\n            return decodeUnsignedInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER: {\n            return decodeNegativeInteger(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING: {\n            return decodeByteString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING: {\n            return decodeString(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY: {\n            return decodeArray(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP: {\n            return decodeMap(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG: {\n            return decodeTag(data, argument, index);\n        }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_SIMPLE_OR_FLOAT: {\n            switch (argument) {\n                case 20:\n                    return [false, 1];\n                case 21:\n                    return [true, 1];\n                case 22:\n                    return [null, 1];\n                case 23:\n                    return [undefined, 1];\n                // 24: Simple value (value 32..255 in following byte)\n                case 25: // IEEE 754 Half-Precision Float (16 bits follow)\n                    return decodeFloat16(data, index);\n                case 26: // IEEE 754 Single-Precision Float (32 bits follow)\n                    return decodeFloat32(data, index);\n                case 27: // IEEE 754 Double-Precision Float (64 bits follow)\n                    return decodeFloat64(data, index);\n                // 28-30: Reserved, not well-formed in the present document\n                // 31: \"break\" stop code for indefinite-length items\n            }\n        }\n    }\n    throw new Error(`Unsupported or not well formed at ${index}`);\n}\nfunction encodeSimple(data) {\n    if (data === true) {\n        return 0xf5;\n    }\n    else if (data === false) {\n        return 0xf4;\n    }\n    else if (data === null) {\n        return 0xf6;\n    }\n    // Else undefined\n    return 0xf7;\n}\nfunction encodeFloat(data) {\n    if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {\n        // Float32\n        const output = new Uint8Array(5);\n        output[0] = 0xfa;\n        const view = new DataView(output.buffer);\n        view.setFloat32(1, data, false);\n        return output;\n    }\n    else {\n        // Float64\n        const output = new Uint8Array(9);\n        output[0] = 0xfb;\n        const view = new DataView(output.buffer);\n        view.setFloat64(1, data, false);\n        return output;\n    }\n}\nfunction encodeNumber(data) {\n    if (typeof data == \"number\") {\n        if (Number.isSafeInteger(data)) {\n            // Encode integer\n            if (data < 0) {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));\n            }\n            else {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n            }\n        }\n        return [encodeFloat(data)];\n    }\n    else {\n        if (data < 0n) {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);\n        }\n        else {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n        }\n    }\n}\nconst ENCODER = new TextEncoder();\nfunction encodeString(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING, data.length));\n    output.push(ENCODER.encode(data));\n}\nfunction encodeBytes(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING, data.length));\n    output.push(data);\n}\nfunction encodeArray(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY, data.length));\n    for (const element of data) {\n        encodePartialCBOR(element, output);\n    }\n}\nfunction encodeMap(data, output) {\n    output.push(new Uint8Array((0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP, data.size)));\n    for (const [key, value] of data.entries()) {\n        encodePartialCBOR(key, output);\n        encodePartialCBOR(value, output);\n    }\n}\nfunction encodeTag(tag, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG, tag.tag));\n    encodePartialCBOR(tag.value, output);\n}\nfunction encodePartialCBOR(data, output) {\n    if (typeof data == \"boolean\" || data === null || data == undefined) {\n        output.push(encodeSimple(data));\n        return;\n    }\n    if (typeof data == \"number\" || typeof data == \"bigint\") {\n        output.push(...encodeNumber(data));\n        return;\n    }\n    if (typeof data == \"string\") {\n        encodeString(data, output);\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        encodeBytes(data, output);\n        return;\n    }\n    if (Array.isArray(data)) {\n        encodeArray(data, output);\n        return;\n    }\n    if (data instanceof Map) {\n        encodeMap(data, output);\n        return;\n    }\n    if (data instanceof CBORTag) {\n        encodeTag(data, output);\n        return;\n    }\n    throw new Error(\"Not implemented\");\n}\n/**\n * Like {decodeCBOR}, but the length of the data is unknown and there is likely\n * more -- possibly unrelated non-CBOR -- data afterwards.\n *\n * Examples:\n *\n * ```ts\n * import {decodePartialCBOR} from './cbor.ts'\n * decodePartialCBOR(new Uint8Array([1, 2, 245, 3, 4]), 2)\n * // returns [true, 1]\n * // It did not decode the leading [1, 2] or trailing [3, 4]\n * ```\n *\n * @param data a data stream to read data from\n * @param index where to start reading in the data stream\n * @returns a tuple of the value followed by bytes read.\n * @throws {Error}\n *   When the data stream ends early or the CBOR data is not well formed\n */\nfunction decodePartialCBOR(data, index) {\n    if (data.byteLength === 0 || data.byteLength <= index || index < 0) {\n        throw new Error(\"No data\");\n    }\n    if (data instanceof Uint8Array) {\n        return decodeNext(new DataView(data.buffer), index);\n    }\n    else if (data instanceof ArrayBuffer) {\n        return decodeNext(new DataView(data), index);\n    }\n    // otherwise, it is a data view\n    return decodeNext(data, index);\n}\n/**\n * Decode CBOR data from a binary stream\n *\n * The entire data stream from [0, length) will be consumed.\n * If you require a partial decoding, see {decodePartialCBOR}.\n *\n * Examples:\n *\n * ```ts\n * import {decodeCBOR, CBORTag, CBORType} from './cbor.ts'\n * decodeCBOR(new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101]));\n * // returns new Map<string | number, CBORType>([\n * //   [\"key\", \"value\"],\n * //   [1, \"another value\"]\n * // ]);\n *\n * const taggedItem = new Uint8Array([217, 4, 210, 101, 104, 101, 108, 108, 111]);\n * decodeCBOR(new DataView(taggedItem.buffer))\n * // returns new CBORTag(1234, \"hello\")\n * ```\n *\n * @param data a data stream, multiple types are supported\n * @returns\n */\nfunction decodeCBOR(data) {\n    const [value, length] = decodePartialCBOR(data, 0);\n    if (length !== data.byteLength) {\n        throw new Error(`Data was decoded, but the whole stream was not processed ${length} != ${data.byteLength}`);\n    }\n    return value;\n}\n/**\n * Encode a supported structure to a CBOR byte string.\n *\n * Example:\n *\n * ```ts\n * import {encodeCBOR, CBORType, CBORTag} from './cbor.ts'\n * encodeCBOR(new Map<string | number, CBORType>([\n *   [\"key\", \"value\"],\n *   [1, \"another value\"]\n * ]));\n * // returns new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32 118, 97, 108, 117, 101])\n *\n * encodeCBOR(new CBORTag(1234, \"hello\"))\n * // returns new UInt8Array([217, 4, 210, 101, 104, 101, 108, 108, 111])\n * ```\n *\n * @param data Data to encode\n * @returns A byte string as a Uint8Array\n * @throws Error\n *   if unsupported data is found during encoding\n */\nfunction encodeCBOR(data) {\n    const results = [];\n    encodePartialCBOR(data, results);\n    let length = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            length += 1;\n        }\n        else {\n            length += result.length;\n        }\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const result of results) {\n        if (typeof result == \"number\") {\n            output[index] = result;\n            index += 1;\n        }\n        else {\n            output.set(result, index);\n            index += result.length;\n        }\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeVA7QUFDelA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywrREFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsK0RBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtEQUFZO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsK0RBQVk7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZWFjdC1uZXh0anMtdGVzdC8uL25vZGVfbW9kdWxlcy9AbGV2aXNjaHVjay90aW55LWNib3IvZXNtL2Nib3IvY2Jvci5qcz9lNGFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZUxlbmd0aCwgZW5jb2RlTGVuZ3RoLCBNQUpPUl9UWVBFX0FSUkFZLCBNQUpPUl9UWVBFX0JZVEVfU1RSSU5HLCBNQUpPUl9UWVBFX01BUCwgTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSLCBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVCwgTUFKT1JfVFlQRV9UQUcsIE1BSk9SX1RZUEVfVEVYVF9TVFJJTkcsIE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUiwgfSBmcm9tIFwiLi9jYm9yX2ludGVybmFsLmpzXCI7XG4vKipcbiAqIEEgdmFsdWUgd2hpY2ggaXMgd3JhcHBlZCB3aXRoIGEgQ0JPUiBUYWcuXG4gKiBTZXZlcmFsIHRhZ3MgYXJlIHJlZ2lzdGVyZWQgd2l0aCBkZWZpbmVkIG1lYW5pbmdzIGxpa2UgMCBmb3IgYSBkYXRlIHN0cmluZy5cbiAqIFRoZXNlIG1lYW5pbmdzIGFyZSAqKm5vdCBpbnRlcnByZXRlZCoqIHdoZW4gZGVjb2RlZCBvciBlbmNvZGVkLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1tdXRhYmxlIHJlY29yZC5cbiAqIElmIHRoZSB0YWcgbnVtYmVyIG9yIHZhbHVlIG5lZWRzIHRvIGNoYW5nZSwgdGhlbiBjb25zdHJ1Y3QgYSBuZXcgdGFnXG4gKi9cbmV4cG9ydCBjbGFzcyBDQk9SVGFnIHtcbiAgICAvKipcbiAgICAgKiBXcmFwIGEgdmFsdWUgd2l0aCBhIHRhZyBudW1iZXIuXG4gICAgICogV2hlbiBlbmNvZGVkLCB0aGlzIHRhZyB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWcgVGFnIG51bWJlclxuICAgICAqIEBwYXJhbSB2YWx1ZSBXcmFwcGVkIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFnLCB2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhZ0lkID0gdGFnO1xuICAgICAgICB0aGlzLnRhZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHRhZyBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgdGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29kZVVuc2lnbmVkSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICByZXR1cm4gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG59XG5mdW5jdGlvbiBkZWNvZGVOZWdhdGl2ZUludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgW3ZhbHVlLCBsZW5ndGhdID0gZGVjb2RlVW5zaWduZWRJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgcmV0dXJuIFstdmFsdWUgLSAxLCBsZW5ndGhdO1xufVxuZnVuY3Rpb24gZGVjb2RlQnl0ZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbbGVuZ3RoVmFsdWUsIGxlbmd0aENvbnN1bWVkXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGNvbnN0IGRhdGFTdGFydEluZGV4ID0gaW5kZXggKyBsZW5ndGhDb25zdW1lZDtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlci5zbGljZShkYXRhU3RhcnRJbmRleCwgZGF0YVN0YXJ0SW5kZXggKyBsZW5ndGhWYWx1ZSkpLFxuICAgICAgICBsZW5ndGhDb25zdW1lZCArIGxlbmd0aFZhbHVlLFxuICAgIF07XG59XG5jb25zdCBURVhUX0RFQ09ERVIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbdmFsdWUsIGxlbmd0aF0gPSBkZWNvZGVCeXRlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgcmV0dXJuIFtURVhUX0RFQ09ERVIuZGVjb2RlKHZhbHVlKSwgbGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUFycmF5KGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGlmIChhcmd1bWVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1tdLCAxXTtcbiAgICB9XG4gICAgY29uc3QgW2xlbmd0aCwgbGVuZ3RoQ29uc3VtZWRdID0gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgbGV0IGNvbnN1bWVkTGVuZ3RoID0gbGVuZ3RoQ29uc3VtZWQ7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBpbmRleCAtIGNvbnN1bWVkTGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyBub3Qgc3VwcG9ydGVkIG9yIHdlbGwgZm9ybWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtkZWNvZGVkVmFsdWUsIGNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgY29uc3VtZWRMZW5ndGggKz0gY29uc3VtZWQ7XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkTGVuZ3RoXTtcbn1cbmNvbnN0IE1BUF9FUlJPUiA9IFwiTWFwIGlzIG5vdCBzdXBwb3J0ZWQgb3Igd2VsbCBmb3JtZWRcIjtcbmZ1bmN0aW9uIGRlY29kZU1hcChkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBpZiAoYXJndW1lbnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgTWFwKCksIDFdO1xuICAgIH1cbiAgICBjb25zdCBbbGVuZ3RoLCBsZW5ndGhDb25zdW1lZF0gPSBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICBsZXQgY29uc3VtZWRMZW5ndGggPSBsZW5ndGhDb25zdW1lZDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVtYWluaW5nRGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIGluZGV4IC0gY29uc3VtZWRMZW5ndGg7XG4gICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQga2V5XG4gICAgICAgIGNvbnN0IFtrZXksIGtleUNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoICs9IGtleUNvbnN1bWVkO1xuICAgICAgICByZW1haW5pbmdEYXRhTGVuZ3RoIC09IGtleUNvbnN1bWVkO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlJ3MgZW5vdWdoIHRvIGhhdmUgYSB2YWx1ZVxuICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFQX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZWNobmljYWxseSBDQk9SIG1hcHMgY2FuIGhhdmUgYW55IHR5cGUgYXMgdGhlIGtleSwgYW5kIHNvIGNhbiBKUyBNYXBzXG4gICAgICAgIC8vIEhvd2V2ZXIsIEpTIE1hcHMgY2FuIG9ubHkgcmVmZXJlbmNlIHN1Y2gga2V5cyBhcyByZWZlcmVuY2VzIHdoaWNoIHdvdWxkXG4gICAgICAgIC8vIHJlcXVpcmUga2V5IGl0ZXJhdGlvbiBhbmQgcGF0dGVybiBtYXRjaGluZy5cbiAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHNpbmNlIHN1Y2gga2V5cyBhcmUgbm90IGluIHVzZSB3aXRoIFdlYkF1dGhuLCB0aGlzXG4gICAgICAgIC8vIGNhcGFiaWxpdHkgaXMgbm90IGltcGxlbWVudGVkIGFuZCB0aGUgdHlwZXMgYXJlIHJlc3RyaWN0ZWQgdG8gc3RyaW5nc1xuICAgICAgICAvLyBhbmQgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BUF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ0JPUiBNYXBzIGFyZSBub3Qgd2VsbCBmb3JtZWQgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzXG4gICAgICAgIGlmIChyZXN1bHQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQgdmFsdWVcbiAgICAgICAgY29uc3QgW3ZhbHVlLCB2YWx1ZUNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoICs9IHZhbHVlQ29uc3VtZWQ7XG4gICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBbcmVzdWx0LCBjb25zdW1lZExlbmd0aF07XG59XG5mdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICsgMyA+IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgZW5kIG9mIEZsb2F0IDE2XCIpO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoZSBmaXJzdCBieXRlXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5nZXRVaW50MTYoaW5kZXggKyAxLCBmYWxzZSk7XG4gICAgLy8gQSBtaW5pbWFsIHNlbGVjdGlvbiBvZiBzdXBwb3J0ZWQgdmFsdWVzXG4gICAgaWYgKHJlc3VsdCA9PSAweDdjMDApIHtcbiAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgM107XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCA9PSAweDdlMDApIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT0gMHhmYzAwKSB7XG4gICAgICAgIHJldHVybiBbLUluZmluaXR5LCAzXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmxvYXQxNiBkYXRhIGlzIHVuc3VwcG9ydGVkXCIpO1xufVxuZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCArIDUgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIGVuZCBvZiBGbG9hdCAzMlwiKTtcbiAgICB9XG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuZ2V0RmxvYXQzMihpbmRleCArIDEsIGZhbHNlKTtcbiAgICAvLyBGaXJzdCBieXRlICsgNCBieXRlIGZsb2F0XG4gICAgcmV0dXJuIFtyZXN1bHQsIDVdO1xufVxuZnVuY3Rpb24gZGVjb2RlRmxvYXQ2NChkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCArIDkgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIGVuZCBvZiBGbG9hdCA2NFwiKTtcbiAgICB9XG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuZ2V0RmxvYXQ2NChpbmRleCArIDEsIGZhbHNlKTtcbiAgICAvLyBGaXJzdCBieXRlICsgOCBieXRlIGZsb2F0XG4gICAgcmV0dXJuIFtyZXN1bHQsIDldO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFnKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGNvbnN0IFt0YWcsIHRhZ0J5dGVzXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGNvbnN0IFt2YWx1ZSwgdmFsdWVCeXRlc10gPSBkZWNvZGVOZXh0KGRhdGEsIGluZGV4ICsgdGFnQnl0ZXMpO1xuICAgIHJldHVybiBbbmV3IENCT1JUYWcodGFnLCB2YWx1ZSksIHRhZ0J5dGVzICsgdmFsdWVCeXRlc107XG59XG5mdW5jdGlvbiBkZWNvZGVOZXh0KGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgdGFnIHZhbHVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBieXRlID0gZGF0YS5nZXRVaW50OChpbmRleCk7XG4gICAgY29uc3QgbWFqb3JUeXBlID0gYnl0ZSA+PiA1O1xuICAgIGNvbnN0IGFyZ3VtZW50ID0gYnl0ZSAmIDB4MWY7XG4gICAgc3dpdGNoIChtYWpvclR5cGUpIHtcbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVI6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVbnNpZ25lZEludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUjoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5lZ2F0aXZlSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9CWVRFX1NUUklORzoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJ5dGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfVEVYVF9TVFJJTkc6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfQVJSQVk6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVBcnJheShkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9NQVA6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVNYXAoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfVEFHOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVGFnKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVDoge1xuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgMV07XG4gICAgICAgICAgICAgICAgLy8gMjQ6IFNpbXBsZSB2YWx1ZSAodmFsdWUgMzIuLjI1NSBpbiBmb2xsb3dpbmcgYnl0ZSlcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBJRUVFIDc1NCBIYWxmLVByZWNpc2lvbiBGbG9hdCAoMTYgYml0cyBmb2xsb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGbG9hdDE2KGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyBJRUVFIDc1NCBTaW5nbGUtUHJlY2lzaW9uIEZsb2F0ICgzMiBiaXRzIGZvbGxvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZsb2F0MzIoZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIElFRUUgNzU0IERvdWJsZS1QcmVjaXNpb24gRmxvYXQgKDY0IGJpdHMgZm9sbG93KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRmxvYXQ2NChkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gMjgtMzA6IFJlc2VydmVkLCBub3Qgd2VsbC1mb3JtZWQgaW4gdGhlIHByZXNlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyAzMTogXCJicmVha1wiIHN0b3AgY29kZSBmb3IgaW5kZWZpbml0ZS1sZW5ndGggaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9yIG5vdCB3ZWxsIGZvcm1lZCBhdCAke2luZGV4fWApO1xufVxuZnVuY3Rpb24gZW5jb2RlU2ltcGxlKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gMHhmNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIDB4ZjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDB4ZjY7XG4gICAgfVxuICAgIC8vIEVsc2UgdW5kZWZpbmVkXG4gICAgcmV0dXJuIDB4Zjc7XG59XG5mdW5jdGlvbiBlbmNvZGVGbG9hdChkYXRhKSB7XG4gICAgaWYgKE1hdGguZnJvdW5kKGRhdGEpID09IGRhdGEgfHwgIU51bWJlci5pc0Zpbml0ZShkYXRhKSB8fCBOdW1iZXIuaXNOYU4oZGF0YSkpIHtcbiAgICAgICAgLy8gRmxvYXQzMlxuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSg1KTtcbiAgICAgICAgb3V0cHV0WzBdID0gMHhmYTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXQuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRGbG9hdDMyKDEsIGRhdGEsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZsb2F0NjRcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoOSk7XG4gICAgICAgIG91dHB1dFswXSA9IDB4ZmI7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0LmJ1ZmZlcik7XG4gICAgICAgIHZpZXcuc2V0RmxvYXQ2NCgxLCBkYXRhLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlTnVtYmVyKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEVuY29kZSBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoZGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiwgTWF0aC5hYnMoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZW5jb2RlRmxvYXQoZGF0YSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGEgPCAwbikge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIsIGRhdGEgKiAtMW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1RFWFRfU1RSSU5HLCBkYXRhLmxlbmd0aCkpO1xuICAgIG91dHB1dC5wdXNoKEVOQ09ERVIuZW5jb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX0JZVEVfU1RSSU5HLCBkYXRhLmxlbmd0aCkpO1xuICAgIG91dHB1dC5wdXNoKGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlQXJyYXkoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfQVJSQVksIGRhdGEubGVuZ3RoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgZW5jb2RlUGFydGlhbENCT1IoZWxlbWVudCwgb3V0cHV0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVNYXAoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2gobmV3IFVpbnQ4QXJyYXkoZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfTUFQLCBkYXRhLnNpemUpKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgICAgZW5jb2RlUGFydGlhbENCT1Ioa2V5LCBvdXRwdXQpO1xuICAgICAgICBlbmNvZGVQYXJ0aWFsQ0JPUih2YWx1ZSwgb3V0cHV0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9UQUcsIHRhZy50YWcpKTtcbiAgICBlbmNvZGVQYXJ0aWFsQ0JPUih0YWcudmFsdWUsIG91dHB1dCk7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJ0aWFsQ0JPUihkYXRhLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJib29sZWFuXCIgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW1wbGUoZGF0YSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTnVtYmVyKGRhdGEpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbmNvZGVTdHJpbmcoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgZW5jb2RlQnl0ZXMoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBlbmNvZGVBcnJheShkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGVuY29kZU1hcChkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ0JPUlRhZykge1xuICAgICAgICBlbmNvZGVUYWcoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG59XG4vKipcbiAqIExpa2Uge2RlY29kZUNCT1J9LCBidXQgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YSBpcyB1bmtub3duIGFuZCB0aGVyZSBpcyBsaWtlbHlcbiAqIG1vcmUgLS0gcG9zc2libHkgdW5yZWxhdGVkIG5vbi1DQk9SIC0tIGRhdGEgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtkZWNvZGVQYXJ0aWFsQ0JPUn0gZnJvbSAnLi9jYm9yLnRzJ1xuICogZGVjb2RlUGFydGlhbENCT1IobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDI0NSwgMywgNF0pLCAyKVxuICogLy8gcmV0dXJucyBbdHJ1ZSwgMV1cbiAqIC8vIEl0IGRpZCBub3QgZGVjb2RlIHRoZSBsZWFkaW5nIFsxLCAyXSBvciB0cmFpbGluZyBbMywgNF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIGEgZGF0YSBzdHJlYW0gdG8gcmVhZCBkYXRhIGZyb21cbiAqIEBwYXJhbSBpbmRleCB3aGVyZSB0byBzdGFydCByZWFkaW5nIGluIHRoZSBkYXRhIHN0cmVhbVxuICogQHJldHVybnMgYSB0dXBsZSBvZiB0aGUgdmFsdWUgZm9sbG93ZWQgYnkgYnl0ZXMgcmVhZC5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICBXaGVuIHRoZSBkYXRhIHN0cmVhbSBlbmRzIGVhcmx5IG9yIHRoZSBDQk9SIGRhdGEgaXMgbm90IHdlbGwgZm9ybWVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVQYXJ0aWFsQ0JPUihkYXRhLCBpbmRleCkge1xuICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IDAgfHwgZGF0YS5ieXRlTGVuZ3RoIDw9IGluZGV4IHx8IGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU5leHQobmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKSwgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU5leHQobmV3IERhdGFWaWV3KGRhdGEpLCBpbmRleCk7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgaXQgaXMgYSBkYXRhIHZpZXdcbiAgICByZXR1cm4gZGVjb2RlTmV4dChkYXRhLCBpbmRleCk7XG59XG4vKipcbiAqIERlY29kZSBDQk9SIGRhdGEgZnJvbSBhIGJpbmFyeSBzdHJlYW1cbiAqXG4gKiBUaGUgZW50aXJlIGRhdGEgc3RyZWFtIGZyb20gWzAsIGxlbmd0aCkgd2lsbCBiZSBjb25zdW1lZC5cbiAqIElmIHlvdSByZXF1aXJlIGEgcGFydGlhbCBkZWNvZGluZywgc2VlIHtkZWNvZGVQYXJ0aWFsQ0JPUn0uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7ZGVjb2RlQ0JPUiwgQ0JPUlRhZywgQ0JPUlR5cGV9IGZyb20gJy4vY2Jvci50cydcbiAqIGRlY29kZUNCT1IobmV3IFVpbnQ4QXJyYXkoWzE2MiwgOTksIDEwNywgMTAxLCAxMjEsIDEwMSwgMTE4LCA5NywgMTA4LCAxMTcsIDEwMSwgMSwgMTA5LCA5NywgMTEwLCAxMTEsIDExNiwgMTA0LCAxMDEsIDExNCwgMzIsIDExOCwgOTcsIDEwOCwgMTE3LCAxMDFdKSk7XG4gKiAvLyByZXR1cm5zIG5ldyBNYXA8c3RyaW5nIHwgbnVtYmVyLCBDQk9SVHlwZT4oW1xuICogLy8gICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAqIC8vICAgWzEsIFwiYW5vdGhlciB2YWx1ZVwiXVxuICogLy8gXSk7XG4gKlxuICogY29uc3QgdGFnZ2VkSXRlbSA9IG5ldyBVaW50OEFycmF5KFsyMTcsIDQsIDIxMCwgMTAxLCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMV0pO1xuICogZGVjb2RlQ0JPUihuZXcgRGF0YVZpZXcodGFnZ2VkSXRlbS5idWZmZXIpKVxuICogLy8gcmV0dXJucyBuZXcgQ0JPUlRhZygxMjM0LCBcImhlbGxvXCIpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSBhIGRhdGEgc3RyZWFtLCBtdWx0aXBsZSB0eXBlcyBhcmUgc3VwcG9ydGVkXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQ0JPUihkYXRhKSB7XG4gICAgY29uc3QgW3ZhbHVlLCBsZW5ndGhdID0gZGVjb2RlUGFydGlhbENCT1IoZGF0YSwgMCk7XG4gICAgaWYgKGxlbmd0aCAhPT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSB3YXMgZGVjb2RlZCwgYnV0IHRoZSB3aG9sZSBzdHJlYW0gd2FzIG5vdCBwcm9jZXNzZWQgJHtsZW5ndGh9ICE9ICR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZSBhIHN1cHBvcnRlZCBzdHJ1Y3R1cmUgdG8gYSBDQk9SIGJ5dGUgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7ZW5jb2RlQ0JPUiwgQ0JPUlR5cGUsIENCT1JUYWd9IGZyb20gJy4vY2Jvci50cydcbiAqIGVuY29kZUNCT1IobmV3IE1hcDxzdHJpbmcgfCBudW1iZXIsIENCT1JUeXBlPihbXG4gKiAgIFtcImtleVwiLCBcInZhbHVlXCJdLFxuICogICBbMSwgXCJhbm90aGVyIHZhbHVlXCJdXG4gKiBdKSk7XG4gKiAvLyByZXR1cm5zIG5ldyBVaW50OEFycmF5KFsxNjIsIDk5LCAxMDcsIDEwMSwgMTIxLCAxMDEsIDExOCwgOTcsIDEwOCwgMTE3LCAxMDEsIDEsIDEwOSwgOTcsIDExMCwgMTExLCAxMTYsIDEwNCwgMTAxLCAxMTQsIDMyIDExOCwgOTcsIDEwOCwgMTE3LCAxMDFdKVxuICpcbiAqIGVuY29kZUNCT1IobmV3IENCT1JUYWcoMTIzNCwgXCJoZWxsb1wiKSlcbiAqIC8vIHJldHVybnMgbmV3IFVJbnQ4QXJyYXkoWzIxNywgNCwgMjEwLCAxMDEsIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIERhdGEgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyBBIGJ5dGUgc3RyaW5nIGFzIGEgVWludDhBcnJheVxuICogQHRocm93cyBFcnJvclxuICogICBpZiB1bnN1cHBvcnRlZCBkYXRhIGlzIGZvdW5kIGR1cmluZyBlbmNvZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQ0JPUihkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGVuY29kZVBhcnRpYWxDQk9SKGRhdGEsIHJlc3VsdHMpO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBvdXRwdXRbaW5kZXhdID0gcmVzdWx0O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5zZXQocmVzdWx0LCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAJOR_TYPE_ARRAY: () => (/* binding */ MAJOR_TYPE_ARRAY),\n/* harmony export */   MAJOR_TYPE_BYTE_STRING: () => (/* binding */ MAJOR_TYPE_BYTE_STRING),\n/* harmony export */   MAJOR_TYPE_MAP: () => (/* binding */ MAJOR_TYPE_MAP),\n/* harmony export */   MAJOR_TYPE_NEGATIVE_INTEGER: () => (/* binding */ MAJOR_TYPE_NEGATIVE_INTEGER),\n/* harmony export */   MAJOR_TYPE_SIMPLE_OR_FLOAT: () => (/* binding */ MAJOR_TYPE_SIMPLE_OR_FLOAT),\n/* harmony export */   MAJOR_TYPE_TAG: () => (/* binding */ MAJOR_TYPE_TAG),\n/* harmony export */   MAJOR_TYPE_TEXT_STRING: () => (/* binding */ MAJOR_TYPE_TEXT_STRING),\n/* harmony export */   MAJOR_TYPE_UNSIGNED_INTEGER: () => (/* binding */ MAJOR_TYPE_UNSIGNED_INTEGER),\n/* harmony export */   decodeLength: () => (/* binding */ decodeLength),\n/* harmony export */   encodeLength: () => (/* binding */ encodeLength)\n/* harmony export */ });\nfunction decodeLength(data, argument, index) {\n    if (argument < 24) {\n        return [argument, 1];\n    }\n    const remainingDataLength = data.byteLength - index - 1;\n    const view = new DataView(data.buffer, index + 1);\n    let output;\n    let bytes = 0;\n    switch (argument) {\n        case 24: {\n            if (remainingDataLength > 0) {\n                output = view.getUint8(0);\n                bytes = 2;\n            }\n            break;\n        }\n        case 25: {\n            if (remainingDataLength > 1) {\n                output = view.getUint16(0, false);\n                bytes = 3;\n            }\n            break;\n        }\n        case 26: {\n            if (remainingDataLength > 3) {\n                output = view.getUint32(0, false);\n                bytes = 5;\n            }\n            break;\n        }\n        case 27: {\n            if (remainingDataLength > 7) {\n                const bigOutput = view.getBigUint64(0, false);\n                // Bound it to [24, MAX_SAFE_INTEGER], where it is safe\n                // to encode as a javascript number\n                if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {\n                    return [Number(bigOutput), 9];\n                }\n            }\n            break;\n        }\n    }\n    if (output && output >= 24) {\n        return [output, bytes];\n    }\n    throw new Error(\"Length not supported or not well formed\");\n}\nconst MAJOR_TYPE_UNSIGNED_INTEGER = 0;\nconst MAJOR_TYPE_NEGATIVE_INTEGER = 1;\nconst MAJOR_TYPE_BYTE_STRING = 2;\nconst MAJOR_TYPE_TEXT_STRING = 3;\nconst MAJOR_TYPE_ARRAY = 4;\nconst MAJOR_TYPE_MAP = 5;\nconst MAJOR_TYPE_TAG = 6;\nconst MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;\nfunction encodeLength(major, argument) {\n    const majorEncoded = major << 5;\n    if (argument < 0) {\n        throw new Error(\"CBOR Data Item argument must not be negative\");\n    }\n    // Convert to bigint first.\n    // Encode integers around and above 32 bits in big endian / network byte order\n    // is unreliable in javascript.\n    // https://tc39.es/ecma262/#sec-bitwise-shift-operators\n    // Bit shifting operations result in 32 bit signed numbers\n    let bigintArgument;\n    if (typeof argument == \"number\") {\n        if (!Number.isInteger(argument)) {\n            throw new Error(\"CBOR Data Item argument must be an integer\");\n        }\n        bigintArgument = BigInt(argument);\n    }\n    else {\n        bigintArgument = argument;\n    }\n    // Negative 0 is not a thing\n    if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {\n        if (bigintArgument == 0n) {\n            throw new Error(\"CBOR Data Item argument cannot be zero when negative\");\n        }\n        bigintArgument = bigintArgument - 1n;\n    }\n    if (bigintArgument > 18446744073709551615n) {\n        throw new Error(\"CBOR number out of range\");\n    }\n    // Encode into 64 bits and extract the tail\n    const buffer = new Uint8Array(8);\n    const view = new DataView(buffer.buffer);\n    view.setBigUint64(0, bigintArgument, false);\n    if (bigintArgument <= 23) {\n        return [majorEncoded | buffer[7]];\n    }\n    else if (bigintArgument <= 255) {\n        return [majorEncoded | 24, buffer[7]];\n    }\n    else if (bigintArgument <= 65535) {\n        return [majorEncoded | 25, ...buffer.slice(6)];\n    }\n    else if (bigintArgument <= 4294967295) {\n        return [\n            majorEncoded | 26,\n            ...buffer.slice(4),\n        ];\n    }\n    else {\n        return [\n            majorEncoded | 27,\n            ...buffer,\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3JfaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LW5leHRqcy10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BsZXZpc2NodWNrL3RpbnktY2Jvci9lc20vY2Jvci9jYm9yX2ludGVybmFsLmpzP2YyZGIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBpZiAoYXJndW1lbnQgPCAyNCkge1xuICAgICAgICByZXR1cm4gW2FyZ3VtZW50LCAxXTtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluaW5nRGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIGluZGV4IC0gMTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBpbmRleCArIDEpO1xuICAgIGxldCBvdXRwdXQ7XG4gICAgbGV0IGJ5dGVzID0gMDtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50KSB7XG4gICAgICAgIGNhc2UgMjQ6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNToge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdmlldy5nZXRVaW50MTYoMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjY6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZpZXcuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OiB7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWdPdXRwdXQgPSB2aWV3LmdldEJpZ1VpbnQ2NCgwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gQm91bmQgaXQgdG8gWzI0LCBNQVhfU0FGRV9JTlRFR0VSXSwgd2hlcmUgaXQgaXMgc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIGVuY29kZSBhcyBhIGphdmFzY3JpcHQgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKGJpZ091dHB1dCA+PSAyNG4gJiYgYmlnT3V0cHV0IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbTnVtYmVyKGJpZ091dHB1dCksIDldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0ID49IDI0KSB7XG4gICAgICAgIHJldHVybiBbb3V0cHV0LCBieXRlc107XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBub3Qgc3VwcG9ydGVkIG9yIG5vdCB3ZWxsIGZvcm1lZFwiKTtcbn1cbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIgPSAwO1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiA9IDE7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9CWVRFX1NUUklORyA9IDI7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9URVhUX1NUUklORyA9IDM7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9BUlJBWSA9IDQ7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9NQVAgPSA1O1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfVEFHID0gNjtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVCA9IDc7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKG1ham9yLCBhcmd1bWVudCkge1xuICAgIGNvbnN0IG1ham9yRW5jb2RlZCA9IG1ham9yIDw8IDU7XG4gICAgaWYgKGFyZ3VtZW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0byBiaWdpbnQgZmlyc3QuXG4gICAgLy8gRW5jb2RlIGludGVnZXJzIGFyb3VuZCBhbmQgYWJvdmUgMzIgYml0cyBpbiBiaWcgZW5kaWFuIC8gbmV0d29yayBieXRlIG9yZGVyXG4gICAgLy8gaXMgdW5yZWxpYWJsZSBpbiBqYXZhc2NyaXB0LlxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYml0d2lzZS1zaGlmdC1vcGVyYXRvcnNcbiAgICAvLyBCaXQgc2hpZnRpbmcgb3BlcmF0aW9ucyByZXN1bHQgaW4gMzIgYml0IHNpZ25lZCBudW1iZXJzXG4gICAgbGV0IGJpZ2ludEFyZ3VtZW50O1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgYmlnaW50QXJndW1lbnQgPSBCaWdJbnQoYXJndW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmlnaW50QXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgMCBpcyBub3QgYSB0aGluZ1xuICAgIGlmIChtYWpvciA9PSBNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIpIHtcbiAgICAgICAgaWYgKGJpZ2ludEFyZ3VtZW50ID09IDBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBjYW5ub3QgYmUgemVybyB3aGVuIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJpZ2ludEFyZ3VtZW50ID0gYmlnaW50QXJndW1lbnQgLSAxbjtcbiAgICB9XG4gICAgaWYgKGJpZ2ludEFyZ3VtZW50ID4gMTg0NDY3NDQwNzM3MDk1NTE2MTVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1IgbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG4gICAgLy8gRW5jb2RlIGludG8gNjQgYml0cyBhbmQgZXh0cmFjdCB0aGUgdGFpbFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlcik7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoMCwgYmlnaW50QXJndW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoYmlnaW50QXJndW1lbnQgPD0gMjMpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCBidWZmZXJbN11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWdpbnRBcmd1bWVudCA8PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCAyNCwgYnVmZmVyWzddXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmlnaW50QXJndW1lbnQgPD0gNjU1MzUpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCAyNSwgLi4uYnVmZmVyLnNsaWNlKDYpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmlnaW50QXJndW1lbnQgPD0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFqb3JFbmNvZGVkIHwgMjYsXG4gICAgICAgICAgICAuLi5idWZmZXIuc2xpY2UoNCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFqb3JFbmNvZGVkIHwgMjcsXG4gICAgICAgICAgICAuLi5idWZmZXIsXG4gICAgICAgIF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.CBORTag),\n/* harmony export */   decodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor/cbor.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlYWN0LW5leHRqcy10ZXN0Ly4vbm9kZV9tb2R1bGVzL0BsZXZpc2NodWNrL3RpbnktY2Jvci9lc20vaW5kZXguanM/ZTk4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDQk9SVGFnLCBkZWNvZGVDQk9SLCBkZWNvZGVQYXJ0aWFsQ0JPUiwgZW5jb2RlQ0JPUiwgfSBmcm9tIFwiLi9jYm9yL2Nib3IuanNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js\n");

/***/ })

};
;